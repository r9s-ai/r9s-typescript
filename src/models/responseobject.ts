/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  ResponseOutputItem,
  ResponseOutputItem$inboundSchema,
} from "./responseoutputitem.js";
import { ResponseTool, ResponseTool$inboundSchema } from "./responsetool.js";
import { ResponseUsage, ResponseUsage$inboundSchema } from "./responseusage.js";

/**
 * The status of the response
 */
export const Status = {
  InProgress: "in_progress",
  Completed: "completed",
  Incomplete: "incomplete",
  Failed: "failed",
  Cancelled: "cancelled",
} as const;
/**
 * The status of the response
 */
export type Status = OpenEnum<typeof Status>;

/**
 * Who is paying for this response
 */
export const Payer = {
  Developer: "developer",
  Organization: "organization",
} as const;
/**
 * Who is paying for this response
 */
export type Payer = OpenEnum<typeof Payer>;

/**
 * Billing information
 */
export type Billing = {
  /**
   * Who is paying for this response
   */
  payer?: Payer | undefined;
};

export type ErrorT = {};

export type IncompleteDetails = {};

export const ResponseObjectEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
export type ResponseObjectEffort = OpenEnum<typeof ResponseObjectEffort>;

/**
 * Reasoning configuration
 */
export type ResponseObjectReasoning = {
  /**
   * Reasoning effort level (none/minimal for fast, low/medium for balanced, high/xhigh for thorough)
   */
  effort?: ResponseObjectEffort | null | undefined;
  /**
   * Summary of reasoning
   */
  summary?: string | null | undefined;
};

/**
 * Service tier used
 */
export const ResponseObjectServiceTier = {
  Auto: "auto",
  Default: "default",
} as const;
/**
 * Service tier used
 */
export type ResponseObjectServiceTier = OpenEnum<
  typeof ResponseObjectServiceTier
>;

export const ResponseObjectType = {
  Text: "text",
  JsonObject: "json_object",
  JsonSchema: "json_schema",
} as const;
export type ResponseObjectType = OpenEnum<typeof ResponseObjectType>;

export type ResponseObjectFormat = {
  type?: ResponseObjectType | undefined;
};

/**
 * Verbosity level
 */
export const ResponseObjectVerbosity = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Verbosity level
 */
export type ResponseObjectVerbosity = OpenEnum<typeof ResponseObjectVerbosity>;

/**
 * Text format configuration
 */
export type ResponseObjectText = {
  format?: ResponseObjectFormat | undefined;
  /**
   * Verbosity level
   */
  verbosity?: ResponseObjectVerbosity | undefined;
};

export type ResponseObject2 = {};

export const ResponseObject1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ResponseObject1 = OpenEnum<typeof ResponseObject1>;

/**
 * Tool choice strategy used
 */
export type ResponseObjectToolChoice = ResponseObject1 | ResponseObject2;

/**
 * Truncation strategy used
 */
export const ResponseObjectTruncation = {
  Auto: "auto",
  Disabled: "disabled",
} as const;
/**
 * Truncation strategy used
 */
export type ResponseObjectTruncation = OpenEnum<
  typeof ResponseObjectTruncation
>;

export type ResponseObject = {
  /**
   * Unique identifier for the response
   */
  id: string;
  object: "response";
  /**
   * Unix timestamp when the response was created
   */
  createdAt: number;
  /**
   * The status of the response
   */
  status: Status;
  /**
   * Whether the response is running in the background
   */
  background?: boolean | undefined;
  /**
   * Billing information
   */
  billing?: Billing | undefined;
  /**
   * Unix timestamp when the response was completed
   */
  completedAt?: number | null | undefined;
  /**
   * Error information if the response failed
   */
  error?: ErrorT | null | undefined;
  /**
   * Details about why the response is incomplete
   */
  incompleteDetails?: IncompleteDetails | null | undefined;
  /**
   * System-level instructions that guided the model's behavior
   */
  instructions?: string | undefined;
  /**
   * Maximum number of tokens to generate
   */
  maxOutputTokens?: number | undefined;
  /**
   * Maximum number of tool calls allowed
   */
  maxToolCalls?: number | null | undefined;
  /**
   * The model used for the response
   */
  model: string;
  /**
   * Array of output items produced by the model
   */
  output?: Array<ResponseOutputItem> | undefined;
  /**
   * Whether parallel tool calls are enabled
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * ID of the previous response in a chain
   */
  previousResponseId?: string | null | undefined;
  /**
   * Key for prompt caching
   */
  promptCacheKey?: string | null | undefined;
  /**
   * Prompt cache retention policy
   */
  promptCacheRetention?: string | null | undefined;
  /**
   * Reasoning configuration
   */
  reasoning?: ResponseObjectReasoning | undefined;
  /**
   * Safety identifier for the response
   */
  safetyIdentifier?: string | null | undefined;
  /**
   * Service tier used
   */
  serviceTier?: ResponseObjectServiceTier | undefined;
  /**
   * Whether to store the response
   */
  store?: boolean | undefined;
  /**
   * Temperature parameter used
   */
  temperature?: number | undefined;
  /**
   * Text format configuration
   */
  text?: ResponseObjectText | undefined;
  /**
   * Tool choice strategy used
   */
  toolChoice?: ResponseObject1 | ResponseObject2 | undefined;
  /**
   * Tools that were available
   */
  tools?: Array<ResponseTool> | undefined;
  /**
   * Number of top log probabilities
   */
  topLogprobs?: number | undefined;
  /**
   * Top-p sampling parameter used
   */
  topP?: number | undefined;
  /**
   * Truncation strategy used
   */
  truncation?: ResponseObjectTruncation | undefined;
  /**
   * User identifier
   */
  user?: string | null | undefined;
  /**
   * Additional metadata
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Usage statistics (null when response is still in progress)
   */
  usage?: ResponseUsage | null | undefined;
};

/** @internal */
export const Status$inboundSchema: z.ZodMiniType<Status, unknown> = openEnums
  .inboundSchema(Status);

/** @internal */
export const Payer$inboundSchema: z.ZodMiniType<Payer, unknown> = openEnums
  .inboundSchema(Payer);

/** @internal */
export const Billing$inboundSchema: z.ZodMiniType<Billing, unknown> = z.object({
  payer: types.optional(Payer$inboundSchema),
});

export function billingFromJSON(
  jsonString: string,
): SafeParseResult<Billing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Billing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Billing' from JSON`,
  );
}

/** @internal */
export const ErrorT$inboundSchema: z.ZodMiniType<ErrorT, unknown> = z.object(
  {},
);

export function errorFromJSON(
  jsonString: string,
): SafeParseResult<ErrorT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ErrorT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ErrorT' from JSON`,
  );
}

/** @internal */
export const IncompleteDetails$inboundSchema: z.ZodMiniType<
  IncompleteDetails,
  unknown
> = z.object({});

export function incompleteDetailsFromJSON(
  jsonString: string,
): SafeParseResult<IncompleteDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncompleteDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncompleteDetails' from JSON`,
  );
}

/** @internal */
export const ResponseObjectEffort$inboundSchema: z.ZodMiniType<
  ResponseObjectEffort,
  unknown
> = openEnums.inboundSchema(ResponseObjectEffort);

/** @internal */
export const ResponseObjectReasoning$inboundSchema: z.ZodMiniType<
  ResponseObjectReasoning,
  unknown
> = z.object({
  effort: z.optional(z.nullable(ResponseObjectEffort$inboundSchema)),
  summary: z.optional(z.nullable(types.string())),
});

export function responseObjectReasoningFromJSON(
  jsonString: string,
): SafeParseResult<ResponseObjectReasoning, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseObjectReasoning$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseObjectReasoning' from JSON`,
  );
}

/** @internal */
export const ResponseObjectServiceTier$inboundSchema: z.ZodMiniType<
  ResponseObjectServiceTier,
  unknown
> = openEnums.inboundSchema(ResponseObjectServiceTier);

/** @internal */
export const ResponseObjectType$inboundSchema: z.ZodMiniType<
  ResponseObjectType,
  unknown
> = openEnums.inboundSchema(ResponseObjectType);

/** @internal */
export const ResponseObjectFormat$inboundSchema: z.ZodMiniType<
  ResponseObjectFormat,
  unknown
> = z.object({
  type: types.optional(ResponseObjectType$inboundSchema),
});

export function responseObjectFormatFromJSON(
  jsonString: string,
): SafeParseResult<ResponseObjectFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseObjectFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseObjectFormat' from JSON`,
  );
}

/** @internal */
export const ResponseObjectVerbosity$inboundSchema: z.ZodMiniType<
  ResponseObjectVerbosity,
  unknown
> = openEnums.inboundSchema(ResponseObjectVerbosity);

/** @internal */
export const ResponseObjectText$inboundSchema: z.ZodMiniType<
  ResponseObjectText,
  unknown
> = z.object({
  format: types.optional(z.lazy(() => ResponseObjectFormat$inboundSchema)),
  verbosity: types.optional(ResponseObjectVerbosity$inboundSchema),
});

export function responseObjectTextFromJSON(
  jsonString: string,
): SafeParseResult<ResponseObjectText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseObjectText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseObjectText' from JSON`,
  );
}

/** @internal */
export const ResponseObject2$inboundSchema: z.ZodMiniType<
  ResponseObject2,
  unknown
> = z.object({});

export function responseObject2FromJSON(
  jsonString: string,
): SafeParseResult<ResponseObject2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseObject2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseObject2' from JSON`,
  );
}

/** @internal */
export const ResponseObject1$inboundSchema: z.ZodMiniType<
  ResponseObject1,
  unknown
> = openEnums.inboundSchema(ResponseObject1);

/** @internal */
export const ResponseObjectToolChoice$inboundSchema: z.ZodMiniType<
  ResponseObjectToolChoice,
  unknown
> = smartUnion([
  ResponseObject1$inboundSchema,
  z.lazy(() => ResponseObject2$inboundSchema),
]);

export function responseObjectToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ResponseObjectToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseObjectToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseObjectToolChoice' from JSON`,
  );
}

/** @internal */
export const ResponseObjectTruncation$inboundSchema: z.ZodMiniType<
  ResponseObjectTruncation,
  unknown
> = openEnums.inboundSchema(ResponseObjectTruncation);

/** @internal */
export const ResponseObject$inboundSchema: z.ZodMiniType<
  ResponseObject,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    object: types.literal("response"),
    created_at: types.number(),
    status: Status$inboundSchema,
    background: types.optional(types.boolean()),
    billing: types.optional(z.lazy(() => Billing$inboundSchema)),
    completed_at: z.optional(z.nullable(types.number())),
    error: z.optional(z.nullable(z.lazy(() => ErrorT$inboundSchema))),
    incomplete_details: z.optional(
      z.nullable(z.lazy(() => IncompleteDetails$inboundSchema)),
    ),
    instructions: types.optional(types.string()),
    max_output_tokens: types.optional(types.number()),
    max_tool_calls: z.optional(z.nullable(types.number())),
    model: types.string(),
    output: types.optional(z.array(ResponseOutputItem$inboundSchema)),
    parallel_tool_calls: types.optional(types.boolean()),
    previous_response_id: z.optional(z.nullable(types.string())),
    prompt_cache_key: z.optional(z.nullable(types.string())),
    prompt_cache_retention: z.optional(z.nullable(types.string())),
    reasoning: types.optional(
      z.lazy(() => ResponseObjectReasoning$inboundSchema),
    ),
    safety_identifier: z.optional(z.nullable(types.string())),
    service_tier: types.optional(ResponseObjectServiceTier$inboundSchema),
    store: types.optional(types.boolean()),
    temperature: types.optional(types.number()),
    text: types.optional(z.lazy(() => ResponseObjectText$inboundSchema)),
    tool_choice: types.optional(
      smartUnion([
        ResponseObject1$inboundSchema,
        z.lazy(() => ResponseObject2$inboundSchema),
      ]),
    ),
    tools: types.optional(z.array(ResponseTool$inboundSchema)),
    top_logprobs: types.optional(types.number()),
    top_p: types.optional(types.number()),
    truncation: types.optional(ResponseObjectTruncation$inboundSchema),
    user: z.optional(z.nullable(types.string())),
    metadata: types.optional(z.record(z.string(), z.any())),
    usage: z.optional(z.nullable(ResponseUsage$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "completed_at": "completedAt",
      "incomplete_details": "incompleteDetails",
      "max_output_tokens": "maxOutputTokens",
      "max_tool_calls": "maxToolCalls",
      "parallel_tool_calls": "parallelToolCalls",
      "previous_response_id": "previousResponseId",
      "prompt_cache_key": "promptCacheKey",
      "prompt_cache_retention": "promptCacheRetention",
      "safety_identifier": "safetyIdentifier",
      "service_tier": "serviceTier",
      "tool_choice": "toolChoice",
      "top_logprobs": "topLogprobs",
      "top_p": "topP",
    });
  }),
);

export function responseObjectFromJSON(
  jsonString: string,
): SafeParseResult<ResponseObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseObject' from JSON`,
  );
}
