/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";

/**
 * Output type (message for final response, function_call for tool calls, reasoning for reasoning trace)
 */
export const ResponseOutputItemType = {
  Message: "message",
  FunctionCall: "function_call",
  Reasoning: "reasoning",
} as const;
/**
 * Output type (message for final response, function_call for tool calls, reasoning for reasoning trace)
 */
export type ResponseOutputItemType = OpenEnum<typeof ResponseOutputItemType>;

/**
 * Output status
 */
export const ResponseOutputItemStatus = {
  Completed: "completed",
  InProgress: "in_progress",
  Incomplete: "incomplete",
} as const;
/**
 * Output status
 */
export type ResponseOutputItemStatus = OpenEnum<
  typeof ResponseOutputItemStatus
>;

/**
 * Message role
 */
export const ResponseOutputItemRole = {
  User: "user",
  Assistant: "assistant",
} as const;
/**
 * Message role
 */
export type ResponseOutputItemRole = OpenEnum<typeof ResponseOutputItemRole>;

/**
 * Content type (text for messages, output_text for responses, reasoning_text for reasoning traces, refusal for safety refusals)
 */
export const ResponseOutputItemSchemasType = {
  Text: "text",
  Refusal: "refusal",
  OutputText: "output_text",
  ReasoningText: "reasoning_text",
} as const;
/**
 * Content type (text for messages, output_text for responses, reasoning_text for reasoning traces, refusal for safety refusals)
 */
export type ResponseOutputItemSchemasType = OpenEnum<
  typeof ResponseOutputItemSchemasType
>;

export type ResponseOutputItemContent = {
  /**
   * Content type (text for messages, output_text for responses, reasoning_text for reasoning traces, refusal for safety refusals)
   */
  type?: ResponseOutputItemSchemasType | undefined;
  /**
   * Text content
   */
  text?: string | undefined;
  /**
   * Refusal content
   */
  refusal?: string | undefined;
  /**
   * Content annotations
   */
  annotations?: Array<any> | undefined;
  /**
   * Log probabilities
   */
  logprobs?: Array<any> | undefined;
};

/**
 * Natural-language summary of reasoning (for reasoning type), can be string or array
 */
export type Summary = string | Array<any>;

export type ResponseOutputItem = {
  /**
   * Unique identifier for output item
   */
  id: string;
  /**
   * Output type (message for final response, function_call for tool calls, reasoning for reasoning trace)
   */
  type: ResponseOutputItemType;
  /**
   * Output status
   */
  status?: ResponseOutputItemStatus | undefined;
  /**
   * Message role
   */
  role?: ResponseOutputItemRole | undefined;
  /**
   * Content array
   */
  content?: Array<ResponseOutputItemContent> | undefined;
  /**
   * Function call ID
   */
  callId?: string | undefined;
  /**
   * Function name
   */
  name?: string | undefined;
  /**
   * Function arguments (JSON string)
   */
  arguments?: string | undefined;
  /**
   * Function output
   */
  output?: string | undefined;
  /**
   * Natural-language summary of reasoning (for reasoning type), can be string or array
   */
  summary?: string | Array<any> | null | undefined;
  /**
   * Encrypted reasoning tokens for stateless workflows (for reasoning type)
   */
  encryptedContent?: string | null | undefined;
};

/** @internal */
export const ResponseOutputItemType$inboundSchema: z.ZodMiniType<
  ResponseOutputItemType,
  unknown
> = openEnums.inboundSchema(ResponseOutputItemType);

/** @internal */
export const ResponseOutputItemStatus$inboundSchema: z.ZodMiniType<
  ResponseOutputItemStatus,
  unknown
> = openEnums.inboundSchema(ResponseOutputItemStatus);

/** @internal */
export const ResponseOutputItemRole$inboundSchema: z.ZodMiniType<
  ResponseOutputItemRole,
  unknown
> = openEnums.inboundSchema(ResponseOutputItemRole);

/** @internal */
export const ResponseOutputItemSchemasType$inboundSchema: z.ZodMiniType<
  ResponseOutputItemSchemasType,
  unknown
> = openEnums.inboundSchema(ResponseOutputItemSchemasType);

/** @internal */
export const ResponseOutputItemContent$inboundSchema: z.ZodMiniType<
  ResponseOutputItemContent,
  unknown
> = z.object({
  type: types.optional(ResponseOutputItemSchemasType$inboundSchema),
  text: types.optional(types.string()),
  refusal: types.optional(types.string()),
  annotations: types.optional(z.array(z.any())),
  logprobs: types.optional(z.array(z.any())),
});

export function responseOutputItemContentFromJSON(
  jsonString: string,
): SafeParseResult<ResponseOutputItemContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseOutputItemContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseOutputItemContent' from JSON`,
  );
}

/** @internal */
export const Summary$inboundSchema: z.ZodMiniType<Summary, unknown> =
  smartUnion([types.string(), z.array(z.any())]);

export function summaryFromJSON(
  jsonString: string,
): SafeParseResult<Summary, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Summary$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Summary' from JSON`,
  );
}

/** @internal */
export const ResponseOutputItem$inboundSchema: z.ZodMiniType<
  ResponseOutputItem,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    type: ResponseOutputItemType$inboundSchema,
    status: types.optional(ResponseOutputItemStatus$inboundSchema),
    role: types.optional(ResponseOutputItemRole$inboundSchema),
    content: types.optional(
      z.array(z.lazy(() => ResponseOutputItemContent$inboundSchema)),
    ),
    call_id: types.optional(types.string()),
    name: types.optional(types.string()),
    arguments: types.optional(types.string()),
    output: types.optional(types.string()),
    summary: z.optional(
      z.nullable(smartUnion([types.string(), z.array(z.any())])),
    ),
    encrypted_content: z.optional(z.nullable(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "call_id": "callId",
      "encrypted_content": "encryptedContent",
    });
  }),
);

export function responseOutputItemFromJSON(
  jsonString: string,
): SafeParseResult<ResponseOutputItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseOutputItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseOutputItem' from JSON`,
  );
}
