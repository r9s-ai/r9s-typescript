/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";

export const AnthropicContentBlockStartType = {
  Text: "text",
  ToolUse: "tool_use",
} as const;
export type AnthropicContentBlockStartType = OpenEnum<
  typeof AnthropicContentBlockStartType
>;

export type AnthropicContentBlockStartInput = {};

export type ContentBlock = {
  type: AnthropicContentBlockStartType;
  text?: string | undefined;
  id?: string | undefined;
  name?: string | undefined;
  input?: AnthropicContentBlockStartInput | undefined;
};

export type AnthropicContentBlockStart = {
  type: "content_block_start";
  index: number;
  contentBlock: ContentBlock;
};

/** @internal */
export const AnthropicContentBlockStartType$inboundSchema: z.ZodMiniType<
  AnthropicContentBlockStartType,
  unknown
> = openEnums.inboundSchema(AnthropicContentBlockStartType);

/** @internal */
export const AnthropicContentBlockStartInput$inboundSchema: z.ZodMiniType<
  AnthropicContentBlockStartInput,
  unknown
> = z.object({});

export function anthropicContentBlockStartInputFromJSON(
  jsonString: string,
): SafeParseResult<AnthropicContentBlockStartInput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AnthropicContentBlockStartInput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AnthropicContentBlockStartInput' from JSON`,
  );
}

/** @internal */
export const ContentBlock$inboundSchema: z.ZodMiniType<ContentBlock, unknown> =
  z.object({
    type: AnthropicContentBlockStartType$inboundSchema,
    text: types.optional(types.string()),
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    input: types.optional(
      z.lazy(() => AnthropicContentBlockStartInput$inboundSchema),
    ),
  });

export function contentBlockFromJSON(
  jsonString: string,
): SafeParseResult<ContentBlock, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentBlock$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentBlock' from JSON`,
  );
}

/** @internal */
export const AnthropicContentBlockStart$inboundSchema: z.ZodMiniType<
  AnthropicContentBlockStart,
  unknown
> = z.pipe(
  z.object({
    type: types.literal("content_block_start"),
    index: types.number(),
    content_block: z.lazy(() => ContentBlock$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "content_block": "contentBlock",
    });
  }),
);

export function anthropicContentBlockStartFromJSON(
  jsonString: string,
): SafeParseResult<AnthropicContentBlockStart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AnthropicContentBlockStart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AnthropicContentBlockStart' from JSON`,
  );
}
