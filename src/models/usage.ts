/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";

/**
 * Details about prompt tokens
 */
export type PromptTokensDetails = {
  /**
   * Number of cached tokens
   */
  cachedTokens?: number | undefined;
  /**
   * Number of audio tokens in the prompt
   */
  audioTokens?: number | undefined;
};

/**
 * Details about completion tokens
 */
export type CompletionTokensDetails = {
  /**
   * Number of reasoning tokens
   */
  reasoningTokens?: number | undefined;
  /**
   * Number of audio tokens
   */
  audioTokens?: number | undefined;
  /**
   * Number of accepted prediction tokens
   */
  acceptedPredictionTokens?: number | undefined;
  /**
   * Number of rejected prediction tokens
   */
  rejectedPredictionTokens?: number | undefined;
};

export type Usage = {
  /**
   * Number of tokens in the prompt (input)
   */
  promptTokens: number;
  /**
   * Details about prompt tokens
   */
  promptTokensDetails?: PromptTokensDetails | undefined;
  /**
   * Number of tokens in the completion (output)
   */
  completionTokens: number;
  /**
   * Details about completion tokens
   */
  completionTokensDetails?: CompletionTokensDetails | undefined;
  /**
   * Total number of tokens (prompt + completion)
   */
  totalTokens: number;
};

/** @internal */
export const PromptTokensDetails$inboundSchema: z.ZodMiniType<
  PromptTokensDetails,
  unknown
> = z.pipe(
  z.object({
    cached_tokens: types.optional(types.number()),
    audio_tokens: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "cached_tokens": "cachedTokens",
      "audio_tokens": "audioTokens",
    });
  }),
);

export function promptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<PromptTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromptTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CompletionTokensDetails$inboundSchema: z.ZodMiniType<
  CompletionTokensDetails,
  unknown
> = z.pipe(
  z.object({
    reasoning_tokens: types.optional(types.number()),
    audio_tokens: types.optional(types.number()),
    accepted_prediction_tokens: types.optional(types.number()),
    rejected_prediction_tokens: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "reasoning_tokens": "reasoningTokens",
      "audio_tokens": "audioTokens",
      "accepted_prediction_tokens": "acceptedPredictionTokens",
      "rejected_prediction_tokens": "rejectedPredictionTokens",
    });
  }),
);

export function completionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CompletionTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompletionTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const Usage$inboundSchema: z.ZodMiniType<Usage, unknown> = z.pipe(
  z.object({
    prompt_tokens: types.number(),
    prompt_tokens_details: types.optional(z.lazy(() =>
      PromptTokensDetails$inboundSchema
    )),
    completion_tokens: types.number(),
    completion_tokens_details: types.optional(z.lazy(() =>
      CompletionTokensDetails$inboundSchema
    )),
    total_tokens: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "prompt_tokens": "promptTokens",
      "prompt_tokens_details": "promptTokensDetails",
      "completion_tokens": "completionTokens",
      "completion_tokens_details": "completionTokensDetails",
      "total_tokens": "totalTokens",
    });
  }),
);

export function usageFromJSON(
  jsonString: string,
): SafeParseResult<Usage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Usage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Usage' from JSON`,
  );
}
