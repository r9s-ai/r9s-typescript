/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  MessageContent,
  MessageContent$inboundSchema,
  MessageContent$Outbound,
  MessageContent$outboundSchema,
} from "./messagecontent.js";
import {
  ToolCall,
  ToolCall$inboundSchema,
  ToolCall$Outbound,
  ToolCall$outboundSchema,
} from "./toolcall.js";

/**
 * Message role
 */
export const Role = {
  System: "system",
  User: "user",
  Assistant: "assistant",
  Tool: "tool",
} as const;
/**
 * Message role
 */
export type Role = OpenEnum<typeof Role>;

/**
 * Message content. Can be null when assistant message contains tool_calls.
 *
 * @remarks
 * - user/system messages: Required, contains text or multimodal content
 * - assistant messages: Optional when tool_calls is present; can be null or omitted
 * - tool messages: Required, contains tool return results (usually JSON string)
 *
 * **Important:** In /v1/responses API, content field must exist and cannot be null.
 * For /v1/chat/completions, content can be null when tool_calls is present.
 */
export type Content = string | Array<MessageContent>;

/**
 * Message object. Note: Different API endpoints have different field requirements and support.
 *
 * @remarks
 *
 * **Field support:**
 * - /v1/chat/completions: Supports all fields (tool_calls, tool_call_id, etc.)
 * - /v1/responses: Only supports basic fields (role, content, name); does not support tool_calls and tool_call_id
 *
 * **content field requirements:**
 * - /v1/chat/completions: When tool_calls is present, content can be omitted or null
 * - /v1/responses: content field is always required and cannot be null; tool_calls field is not supported
 */
export type Message = {
  /**
   * Message role
   */
  role: Role;
  /**
   * Message content. Can be null when assistant message contains tool_calls.
   *
   * @remarks
   * - user/system messages: Required, contains text or multimodal content
   * - assistant messages: Optional when tool_calls is present; can be null or omitted
   * - tool messages: Required, contains tool return results (usually JSON string)
   *
   * **Important:** In /v1/responses API, content field must exist and cannot be null.
   * For /v1/chat/completions, content can be null when tool_calls is present.
   */
  content?: string | Array<MessageContent> | null | undefined;
  /**
   * Sender name
   */
  name?: string | undefined;
  /**
   * Reasoning content
   */
  reasoningContent?: string | undefined;
  /**
   * Tool calls list
   */
  toolCalls?: Array<ToolCall> | undefined;
  /**
   * Tool call ID
   */
  toolCallId?: string | undefined;
};

/** @internal */
export const Role$inboundSchema: z.ZodMiniType<Role, unknown> = openEnums
  .inboundSchema(Role);
/** @internal */
export const Role$outboundSchema: z.ZodMiniType<string, Role> = openEnums
  .outboundSchema(Role);

/** @internal */
export const Content$inboundSchema: z.ZodMiniType<Content, unknown> =
  smartUnion([types.string(), z.array(MessageContent$inboundSchema)]);
/** @internal */
export type Content$Outbound = string | Array<MessageContent$Outbound>;

/** @internal */
export const Content$outboundSchema: z.ZodMiniType<Content$Outbound, Content> =
  smartUnion([z.string(), z.array(MessageContent$outboundSchema)]);

export function contentToJSON(content: Content): string {
  return JSON.stringify(Content$outboundSchema.parse(content));
}
export function contentFromJSON(
  jsonString: string,
): SafeParseResult<Content, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content' from JSON`,
  );
}

/** @internal */
export const Message$inboundSchema: z.ZodMiniType<Message, unknown> = z.pipe(
  z.object({
    role: Role$inboundSchema,
    content: z.optional(
      z.nullable(
        smartUnion([types.string(), z.array(MessageContent$inboundSchema)]),
      ),
    ),
    name: types.optional(types.string()),
    reasoning_content: types.optional(types.string()),
    tool_calls: types.optional(z.array(ToolCall$inboundSchema)),
    tool_call_id: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "reasoning_content": "reasoningContent",
      "tool_calls": "toolCalls",
      "tool_call_id": "toolCallId",
    });
  }),
);
/** @internal */
export type Message$Outbound = {
  role: string;
  content?: string | Array<MessageContent$Outbound> | null | undefined;
  name?: string | undefined;
  reasoning_content?: string | undefined;
  tool_calls?: Array<ToolCall$Outbound> | undefined;
  tool_call_id?: string | undefined;
};

/** @internal */
export const Message$outboundSchema: z.ZodMiniType<Message$Outbound, Message> =
  z.pipe(
    z.object({
      role: Role$outboundSchema,
      content: z.optional(
        z.nullable(
          smartUnion([z.string(), z.array(MessageContent$outboundSchema)]),
        ),
      ),
      name: z.optional(z.string()),
      reasoningContent: z.optional(z.string()),
      toolCalls: z.optional(z.array(ToolCall$outboundSchema)),
      toolCallId: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        reasoningContent: "reasoning_content",
        toolCalls: "tool_calls",
        toolCallId: "tool_call_id",
      });
    }),
  );

export function messageToJSON(message: Message): string {
  return JSON.stringify(Message$outboundSchema.parse(message));
}
export function messageFromJSON(
  jsonString: string,
): SafeParseResult<Message, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message' from JSON`,
  );
}
