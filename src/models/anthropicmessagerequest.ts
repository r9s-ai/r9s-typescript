/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { ClosedEnum } from "../types/enums.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  AnthropicMessageMessage,
  AnthropicMessageMessage$Outbound,
  AnthropicMessageMessage$outboundSchema,
} from "./anthropicmessagemessage.js";
import {
  AnthropicTool,
  AnthropicTool$Outbound,
  AnthropicTool$outboundSchema,
} from "./anthropictool.js";

export type AnthropicMessageRequest2 = {
  type?: "tool" | undefined;
  name?: string | undefined;
};

export const AnthropicMessageRequest1 = {
  None: "none",
  Auto: "auto",
  Any: "any",
} as const;
export type AnthropicMessageRequest1 = ClosedEnum<
  typeof AnthropicMessageRequest1
>;

export type AnthropicMessageRequestToolChoice =
  | AnthropicMessageRequest1
  | AnthropicMessageRequest2;

/**
 * Whether to enable extended thinking
 */
export const AnthropicMessageRequestType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Whether to enable extended thinking
 */
export type AnthropicMessageRequestType = ClosedEnum<
  typeof AnthropicMessageRequestType
>;

/**
 * Configuration for extended thinking (Claude 3.7+). When enabled, the model will spend more time thinking before responding.
 *
 * @remarks
 */
export type Thinking = {
  /**
   * Whether to enable extended thinking
   */
  type?: AnthropicMessageRequestType | undefined;
  /**
   * Maximum number of tokens to use for thinking (1000-10000)
   */
  budgetTokens?: number | undefined;
};

/**
 * Service tier for request processing:
 *
 * @remarks
 * - auto: Automatically select between standard and priority capacity
 * - standard_only: Only use standard capacity (may have longer wait times during high load)
 */
export const AnthropicMessageRequestServiceTier = {
  Auto: "auto",
  StandardOnly: "standard_only",
} as const;
/**
 * Service tier for request processing:
 *
 * @remarks
 * - auto: Automatically select between standard and priority capacity
 * - standard_only: Only use standard capacity (may have longer wait times during high load)
 */
export type AnthropicMessageRequestServiceTier = ClosedEnum<
  typeof AnthropicMessageRequestServiceTier
>;

export type AnthropicMessageRequest = {
  /**
   * Claude model name
   */
  model: string;
  /**
   * Messages list, first message must be a user message
   */
  messages: Array<AnthropicMessageMessage>;
  /**
   * System prompt
   */
  system?: string | undefined;
  /**
   * Maximum number of output tokens (optional).
   *
   * @remarks
   * If not provided, the relay service or API may use a default value.
   * Different models have different maximum values.
   */
  maxTokens?: number | undefined;
  /**
   * Stop sequences
   */
  stopSequences?: Array<string> | undefined;
  stream?: boolean | undefined;
  temperature?: number | undefined;
  topP?: number | undefined;
  /**
   * Top-k sampling parameter. Only sample from the top K options for each subsequent token.
   */
  topK?: number | undefined;
  tools?: Array<AnthropicTool> | undefined;
  toolChoice?: AnthropicMessageRequest1 | AnthropicMessageRequest2 | undefined;
  /**
   * An object describing metadata about the request. Can be used for tracking, identification, or filtering purposes.
   *
   * @remarks
   * Common use cases: user_id, session_id, request_id, etc.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Configuration for extended thinking (Claude 3.7+). When enabled, the model will spend more time thinking before responding.
   *
   * @remarks
   */
  thinking?: Thinking | undefined;
  /**
   * Service tier for request processing:
   *
   * @remarks
   * - auto: Automatically select between standard and priority capacity
   * - standard_only: Only use standard capacity (may have longer wait times during high load)
   */
  serviceTier?: AnthropicMessageRequestServiceTier | undefined;
};

/** @internal */
export type AnthropicMessageRequest2$Outbound = {
  type?: "tool" | undefined;
  name?: string | undefined;
};

/** @internal */
export const AnthropicMessageRequest2$outboundSchema: z.ZodMiniType<
  AnthropicMessageRequest2$Outbound,
  AnthropicMessageRequest2
> = z.object({
  type: z.optional(z.literal("tool")),
  name: z.optional(z.string()),
});

export function anthropicMessageRequest2ToJSON(
  anthropicMessageRequest2: AnthropicMessageRequest2,
): string {
  return JSON.stringify(
    AnthropicMessageRequest2$outboundSchema.parse(anthropicMessageRequest2),
  );
}

/** @internal */
export const AnthropicMessageRequest1$outboundSchema: z.ZodMiniEnum<
  typeof AnthropicMessageRequest1
> = z.enum(AnthropicMessageRequest1);

/** @internal */
export type AnthropicMessageRequestToolChoice$Outbound =
  | string
  | AnthropicMessageRequest2$Outbound;

/** @internal */
export const AnthropicMessageRequestToolChoice$outboundSchema: z.ZodMiniType<
  AnthropicMessageRequestToolChoice$Outbound,
  AnthropicMessageRequestToolChoice
> = smartUnion([
  AnthropicMessageRequest1$outboundSchema,
  z.lazy(() => AnthropicMessageRequest2$outboundSchema),
]);

export function anthropicMessageRequestToolChoiceToJSON(
  anthropicMessageRequestToolChoice: AnthropicMessageRequestToolChoice,
): string {
  return JSON.stringify(
    AnthropicMessageRequestToolChoice$outboundSchema.parse(
      anthropicMessageRequestToolChoice,
    ),
  );
}

/** @internal */
export const AnthropicMessageRequestType$outboundSchema: z.ZodMiniEnum<
  typeof AnthropicMessageRequestType
> = z.enum(AnthropicMessageRequestType);

/** @internal */
export type Thinking$Outbound = {
  type: string;
  budget_tokens?: number | undefined;
};

/** @internal */
export const Thinking$outboundSchema: z.ZodMiniType<
  Thinking$Outbound,
  Thinking
> = z.pipe(
  z.object({
    type: z._default(AnthropicMessageRequestType$outboundSchema, "disabled"),
    budgetTokens: z.optional(z.int()),
  }),
  z.transform((v) => {
    return remap$(v, {
      budgetTokens: "budget_tokens",
    });
  }),
);

export function thinkingToJSON(thinking: Thinking): string {
  return JSON.stringify(Thinking$outboundSchema.parse(thinking));
}

/** @internal */
export const AnthropicMessageRequestServiceTier$outboundSchema: z.ZodMiniEnum<
  typeof AnthropicMessageRequestServiceTier
> = z.enum(AnthropicMessageRequestServiceTier);

/** @internal */
export type AnthropicMessageRequest$Outbound = {
  model: string;
  messages: Array<AnthropicMessageMessage$Outbound>;
  system?: string | undefined;
  max_tokens?: number | undefined;
  stop_sequences?: Array<string> | undefined;
  stream: boolean;
  temperature?: number | undefined;
  top_p?: number | undefined;
  top_k?: number | undefined;
  tools?: Array<AnthropicTool$Outbound> | undefined;
  tool_choice?: string | AnthropicMessageRequest2$Outbound | undefined;
  metadata?: { [k: string]: any } | undefined;
  thinking?: Thinking$Outbound | undefined;
  service_tier: string;
};

/** @internal */
export const AnthropicMessageRequest$outboundSchema: z.ZodMiniType<
  AnthropicMessageRequest$Outbound,
  AnthropicMessageRequest
> = z.pipe(
  z.object({
    model: z.string(),
    messages: z.array(AnthropicMessageMessage$outboundSchema),
    system: z.optional(z.string()),
    maxTokens: z.optional(z.int()),
    stopSequences: z.optional(z.array(z.string())),
    stream: z._default(z.boolean(), false),
    temperature: z.optional(z.number()),
    topP: z.optional(z.number()),
    topK: z.optional(z.int()),
    tools: z.optional(z.array(AnthropicTool$outboundSchema)),
    toolChoice: z.optional(
      smartUnion([
        AnthropicMessageRequest1$outboundSchema,
        z.lazy(() => AnthropicMessageRequest2$outboundSchema),
      ]),
    ),
    metadata: z.optional(z.record(z.string(), z.any())),
    thinking: z.optional(z.lazy(() => Thinking$outboundSchema)),
    serviceTier: z._default(
      AnthropicMessageRequestServiceTier$outboundSchema,
      "auto",
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      maxTokens: "max_tokens",
      stopSequences: "stop_sequences",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      serviceTier: "service_tier",
    });
  }),
);

export function anthropicMessageRequestToJSON(
  anthropicMessageRequest: AnthropicMessageRequest,
): string {
  return JSON.stringify(
    AnthropicMessageRequest$outboundSchema.parse(anthropicMessageRequest),
  );
}
