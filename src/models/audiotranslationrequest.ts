/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { blobLikeSchema } from "../types/blobs.js";
import { ClosedEnum } from "../types/enums.js";

export type AudioTranslationRequestFile = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/**
 * Output format for the translated text
 */
export const AudioTranslationRequestResponseFormat = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
/**
 * Output format for the translated text
 */
export type AudioTranslationRequestResponseFormat = ClosedEnum<
  typeof AudioTranslationRequestResponseFormat
>;

export type AudioTranslationRequest = {
  /**
   * Audio file to translate to English
   */
  file: AudioTranslationRequestFile | Blob;
  /**
   * Model name (whisper-1 is primary, gpt-4o-transcribe has extended support)
   */
  model: string;
  /**
   * Optional text prompt to guide the model's style.
   *
   * @remarks
   * The source language can be specified in the prompt if needed, though the model will auto-detect it.
   */
  prompt?: string | undefined;
  /**
   * Output format for the translated text
   */
  responseFormat?: AudioTranslationRequestResponseFormat | undefined;
  /**
   * Sampling temperature between 0 and 1
   */
  temperature?: number | undefined;
};

/** @internal */
export type AudioTranslationRequestFile$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const AudioTranslationRequestFile$outboundSchema: z.ZodMiniType<
  AudioTranslationRequestFile$Outbound,
  AudioTranslationRequestFile
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.custom<ReadableStream<Uint8Array>>(x => x instanceof ReadableStream),
    z.custom<Blob>(x => x instanceof Blob),
    z.custom<ArrayBuffer>(x => x instanceof ArrayBuffer),
    z.custom<Uint8Array>(x => x instanceof Uint8Array),
  ]),
});

export function audioTranslationRequestFileToJSON(
  audioTranslationRequestFile: AudioTranslationRequestFile,
): string {
  return JSON.stringify(
    AudioTranslationRequestFile$outboundSchema.parse(
      audioTranslationRequestFile,
    ),
  );
}

/** @internal */
export const AudioTranslationRequestResponseFormat$outboundSchema:
  z.ZodMiniEnum<typeof AudioTranslationRequestResponseFormat> = z.enum(
    AudioTranslationRequestResponseFormat,
  );

/** @internal */
export type AudioTranslationRequest$Outbound = {
  file: AudioTranslationRequestFile$Outbound | Blob;
  model: string;
  prompt?: string | undefined;
  response_format: string;
  temperature: number;
};

/** @internal */
export const AudioTranslationRequest$outboundSchema: z.ZodMiniType<
  AudioTranslationRequest$Outbound,
  AudioTranslationRequest
> = z.pipe(
  z.object({
    file: z.union([
      z.lazy(() => AudioTranslationRequestFile$outboundSchema),
      blobLikeSchema,
    ]),
    model: z.string(),
    prompt: z.optional(z.string()),
    responseFormat: z._default(
      AudioTranslationRequestResponseFormat$outboundSchema,
      "json",
    ),
    temperature: z._default(z.number(), 0),
  }),
  z.transform((v) => {
    return remap$(v, {
      responseFormat: "response_format",
    });
  }),
);

export function audioTranslationRequestToJSON(
  audioTranslationRequest: AudioTranslationRequest,
): string {
  return JSON.stringify(
    AudioTranslationRequest$outboundSchema.parse(audioTranslationRequest),
  );
}
